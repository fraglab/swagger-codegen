{{>licenseInfo}}
{{#operations}}

#include "{{classname}}.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>
#include <boost/range/algorithm.hpp>

{{#apiNamespaceDeclarations}}
namespace {{this}} {
{{/apiNamespaceDeclarations}}

using namespace {{modelNamespace}};
using namespace {{invokerNamespace}};


{{classname}}::{{classname}}( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
    {{#operation}}
    SetQosLimit("{{operationId}}", 1);
    {{/operation}}
}

{{classname}}::~{{classname}}()
{
}

{{#operation}}
RequestTask<{{#returnType}}HttpResponseT<{{{returnType}}}>{{/returnType}}{{^returnType}}HttpResponse{{/returnType}}> {{classname}}::{{operationId}}({{#allParams}}{{{dataType}}} {{paramName}}{{^required}}{{/required}}{{#hasMore}}, {{/hasMore}}{{/allParams}}{{#hasParams}}, {{/hasParams}}const pplx::cancellation_token& token, RetryInfo&& retryInfo)
{
{{#returnType}}
    using RequestResponse = HttpResponseT<{{{returnType}}}>;
{{/returnType}}
{{^returnType}}
    using RequestResponse = HttpResponse;
{{/returnType}}

    utility::string_t responseHttpContentType;

    HttpRequestInfo reqInfo = {{operationId}}RequestInfo({{#pathParams}}{{paramName}}{{^required}}{{/required}}{{#hasMore}}, {{/hasMore}}{{/pathParams}});

    if (!IsQosDisabled("{{operationId}}") && IsQosLimitReached("{{operationId}}"))
    {
        auto ex = ApiException(429, _XPLATSTR("Error calling {{classname}}.{{operationId}}: QoS limit reached"));
        return RequestTask<RequestResponse>(reqInfo, pplx::task_from_exception<RequestResponse>(ex));
    }

    auto pQosTracker = std::make_shared<QosTracker>("{{operationId}}", shared_from_this());

    try
    {
{{#allParams}}
{{#required}}
{{^isPrimitiveType}}
{{^isContainer}}
        // verify the required parameter '{{paramName}}' is set
        if ({{paramName}} == nullptr)
        {
            throw ApiException(400, _XPLATSTR("Error calling {{classname}}.{{operationId}}: missing required parameter '{{paramName}}'"));
        }
{{/isContainer}}
{{/isPrimitiveType}}
{{/required}}
{{/allParams}}
        std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );

        std::map<utility::string_t, utility::string_t> queryParams;
        std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
        std::map<utility::string_t, utility::string_t> formParams;
        std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

        std::unordered_set<utility::string_t> responseHttpContentTypes;
        std::unordered_set<utility::string_t>::iterator it;

{{#produces}}
        responseHttpContentTypes.insert( _XPLATSTR("{{mediaType}}") );
{{/produces}}

        // use JSON if possible
        if ( responseHttpContentTypes.size() == 0 )
        {
{{#vendorExtensions.x-codegen-response.isString}}
            responseHttpContentType = _XPLATSTR("text/plain");
{{/vendorExtensions.x-codegen-response.isString}}
{{^vendorExtensions.x-codegen-response.isString}}
            responseHttpContentType = _XPLATSTR("application/json");
{{/vendorExtensions.x-codegen-response.isString}}
        }
        // any JSON
        else if ( responseHttpContentTypes.end() != ( it = boost::find_if(responseHttpContentTypes, [](const utility::string_t& str) {return str.rfind(_XPLATSTR("json")) != utility::string_t::npos;}) ) )
        {
            responseHttpContentType = *it;
        }
        // multipart formdata
        else if( responseHttpContentTypes.find(_XPLATSTR("multipart/form-data")) != responseHttpContentTypes.end() )
        {
            responseHttpContentType = _XPLATSTR("multipart/form-data");
        }
{{#vendorExtensions.x-codegen-response.isString}}
        // plain text
        else if( responseHttpContentTypes.find(_XPLATSTR("text/plain")) != responseHttpContentTypes.end() )
        {
            responseHttpContentType = _XPLATSTR("text/plain");
        }
{{/vendorExtensions.x-codegen-response.isString}}
{{#vendorExtensions.x-codegen-response-ishttpcontent}}
        else
        {
            //It's going to be binary, so just use the first one.
            responseHttpContentType = *responseHttpContentTypes.begin();
        }
{{/vendorExtensions.x-codegen-response-ishttpcontent}}
{{^vendorExtensions.x-codegen-response-ishttpcontent}}
        else
        {
            throw ApiException(400, _XPLATSTR("Error calling {{classname}}.{{operationId}}: operation does not produce any supported media type"));
        }
{{/vendorExtensions.x-codegen-response-ishttpcontent}}

        headerParams[_XPLATSTR("Accept")] = responseHttpContentType;

        std::unordered_set<utility::string_t> consumeHttpContentTypes;
{{#consumes}}
        consumeHttpContentTypes.insert( _XPLATSTR("{{mediaType}}") );
{{/consumes}}

{{#allParams}}
{{^isBodyParam}}
{{^isPathParam}}
{{^isPrimitiveType}}
{{^isContainer}}
        if ({{paramName}} != nullptr)
{{/isContainer}}
{{/isPrimitiveType}}
        {
{{#isContainer}}
{{#isQueryParam}}
            queryParams[_XPLATSTR("{{baseName}}")] = ApiClient::parameterToArrayString<{{items.datatype}}>({{paramName}});
{{/isQueryParam}}
{{#isHeaderParam}}
            headerParams[_XPLATSTR("{{baseName}}")] = ApiClient::parameterToArrayString<{{items.datatype}}>({{paramName}});
{{/isHeaderParam}}
{{#isFormParam}}
{{^isFile}}
            formParams[ _XPLATSTR("{{baseName}}") ] = ApiClient::parameterToArrayString<{{items.datatype}}>({{paramName}});
{{/isFile}}
{{/isFormParam}}
{{/isContainer}}
{{^isContainer}}
{{#isQueryParam}}
            queryParams[_XPLATSTR("{{baseName}}")] = ApiClient::parameterToString({{paramName}});
{{/isQueryParam}}
{{#isHeaderParam}}
            headerParams[_XPLATSTR("{{baseName}}")] = ApiClient::parameterToString({{paramName}});
{{/isHeaderParam}}
{{#isFormParam}}
{{#isFile}}
            fileParams[ _XPLATSTR("{{baseName}}") ] = {{paramName}};
{{/isFile}}
{{^isFile}}
            formParams[ _XPLATSTR("{{baseName}}") ] = ApiClient::parameterToString({{paramName}});
{{/isFile}}
{{/isFormParam}}
{{/isContainer}}
        }
{{/isPathParam}}
{{/isBodyParam}}
{{/allParams}}

        std::shared_ptr<IHttpBody> httpBody;
        utility::string_t requestHttpContentType;

        // use JSON if possible
        if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.end() != ( it = boost::find_if(consumeHttpContentTypes, [](const utility::string_t& str) {return str.rfind(_XPLATSTR("json")) != utility::string_t::npos;}) ) )
        {
            requestHttpContentType = *it;
{{#bodyParam}}
            web::json::value json;

{{#isPrimitiveType}}
            json = ModelBase::toJson({{paramName}});
{{/isPrimitiveType}}
{{^isPrimitiveType}}
{{#isListContainer}}
            {
                std::vector<web::json::value> jsonArray;
                for( auto& item : {{paramName}} )
                {
{{#items.isPrimitiveType}}
                    jsonArray.push_back(ModelBase::toJson(item));
{{/items.isPrimitiveType}}
{{^items.isPrimitiveType}}
{{#items.isString}}
                    jsonArray.push_back(ModelBase::toJson(item));
{{/items.isString}}
{{^items.isString}}
{{#items.isDateTime}}
                    jsonArray.push_back(ModelBase::toJson(item));
{{/items.isDateTime}}
{{^items.isDateTime}}
                    jsonArray.push_back( item.get() ? item->toJson() : web::json::value::null() );
{{/items.isDateTime}}
{{/items.isString}}
{{/items.isPrimitiveType}}
                }
                json = web::json::value::array(jsonArray);
            }
{{/isListContainer}}
{{^isListContainer}}
            json = ModelBase::toJson({{paramName}});
{{/isListContainer}}
{{/isPrimitiveType}}

            httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
{{/bodyParam}}
        }
        // multipart formdata
        else if( consumeHttpContentTypes.find(_XPLATSTR("multipart/form-data")) != consumeHttpContentTypes.end() )
        {
            requestHttpContentType = _XPLATSTR("multipart/form-data");
{{#bodyParam}}
            std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
{{#isPrimitiveType}}
            multipart->add(ModelBase::toHttpContent("{{paramName}}", {{paramName}}));
{{/isPrimitiveType}}
{{^isPrimitiveType}}
{{#isListContainer}}
            {
                std::vector<web::json::value> jsonArray;

                for( auto& item : {{paramName}} )
                {
{{#items.isPrimitiveType}}
                    jsonArray.push_back(ModelBase::toJson(item));
{{/items.isPrimitiveType}}
{{^items.isPrimitiveType}}
{{#items.isString}}
                    jsonArray.push_back(ModelBase::toJson(item));
{{/items.isString}}
{{^items.isString}}
{{#items.isDateTime}}
                    jsonArray.push_back(ModelBase::toJson(item));
{{/items.isDateTime}}
{{^items.isDateTime}}
                    jsonArray.push_back( item.get() ? item->toJson() : web::json::value::null() );
{{/items.isDateTime}}
{{/items.isString}}
{{/items.isPrimitiveType}}
                }

                multipart->add(ModelBase::toHttpContent(_XPLATSTR("{{paramName}}"), web::json::value::array(jsonArray), _XPLATSTR("application/json")));
            }
{{/isListContainer}}
{{^isListContainer}}
{{#isString}}
            multipart->add(ModelBase::toHttpContent(_XPLATSTR("{{paramName}}"), {{paramName}}));
{{/isString}}
{{^isString}}
            if({{paramName}}.get())
            {
                {{paramName}}->toMultipart(multipart, _XPLATSTR("{{paramName}}"));
            }
{{/isString}}
{{/isListContainer}}
{{/isPrimitiveType}}

            httpBody = multipart;
            requestHttpContentType += _XPLATSTR("; boundary=") + multipart->getBoundary();
{{/bodyParam}}
        }
        else
        {
            throw ApiException(415, _XPLATSTR("Error calling {{classname}}.{{operationId}}: operation does not consume any supported media type"));
        }

        //Set the request content type in the header.
        headerParams[_XPLATSTR("Content-Type")] = requestHttpContentType;

{{#authMethods}}
        // authentication ({{name}}) required
{{#isApiKey}}
{{#isKeyInHeader}}
        {
            utility::string_t apiKey = apiConfiguration->getApiKey(_XPLATSTR("{{keyParamName}}"));
            if ( apiKey.size() > 0 )
            {
                headerParams[_XPLATSTR("{{keyParamName}}")] = apiKey;
            }
        }
{{/isKeyInHeader}}
{{#isKeyInQuery}}
        {
            utility::string_t apiKey = apiConfiguration->getApiKey(_XPLATSTR("{{keyParamName}}"));
            if ( apiKey.size() > 0 )
            {
                queryParams[_XPLATSTR("{{keyParamName}}")] = apiKey;
            }
        }
{{/isKeyInQuery}}
{{/isApiKey}}
{{#isBasic}}
        // Basic authentication is added automatically as part of the http_client_config
{{/isBasic}}
{{#isOAuth}}
        // oauth2 authentication is added automatically as part of the http_client_config
{{/isOAuth}}
{{/authMethods}}

        auto taskGenerator = [ reqInfo =                 Helpers::make_implicitly_movable(std::move(reqInfo))
                             , queryParams =             Helpers::make_implicitly_movable(std::move(queryParams))
                             , httpBody =                Helpers::make_implicitly_movable(std::move(httpBody))
                             , headerParams =            Helpers::make_implicitly_movable(std::move(headerParams))
                             , formParams =              Helpers::make_implicitly_movable(std::move(formParams))
                             , fileParams =              Helpers::make_implicitly_movable(std::move(fileParams))
                             , requestHttpContentType =  Helpers::make_implicitly_movable(std::move(requestHttpContentType))
                             , responseHttpContentType = Helpers::make_implicitly_movable(std::move(responseHttpContentType))
                             , token
                             , pQosTracker
                             , this]()
        {
            Task<web::http::http_response> task = m_ApiClient->callApi(reqInfo.value().getUrl()
                                                                     , reqInfo.value().getHttpMethod()
                                                                     , queryParams.value()
                                                                     , httpBody.value()
                                                                     , headerParams.value()
                                                                     , formParams.value()
                                                                     , fileParams.value()
                                                                     , requestHttpContentType.value()
                                                                     , token);

            return task.then([ responseHttpContentType = responseHttpContentType.value(), pQosTracker ](web::http::http_response response)
            {
                pQosTracker;

{{#responses}}
{{#isCustomError}}
                if (response.status_code() == {{{code}}})
                {
                auto rawErrorDesc = response.extract_string(true).get();
                {{{dataType}}} errorDesc(new {{{baseType}}}());
                web::json::value json = web::json::value::parse(rawErrorDesc);
                errorDesc->fromJson(json);

                return pplx::task_from_exception<RequestResponse>(ApiException(response.status_code()
                                                                , _XPLATSTR("Error calling {{classname}}.{{operationId}}: ") + errorDesc->getCode()
                                                                , response.headers()
                                                                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get())));
                }
{{/isCustomError}}
{{/responses}}
                // 1xx - informational : OK
                // 2xx - successful    : OK
                // 3xx - redirection   : OK
                // 4xx - client error  : not OK
                // 5xx - client error  : not OK
                if (response.status_code() >= 400)
                {
                    return pplx::task_from_exception<RequestResponse>(ApiException(response.status_code()
                                                                    , _XPLATSTR("Error calling {{classname}}.{{operationId}}: ") + response.reason_phrase()
                                                                    , response.headers()
                                                                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get())));
                }

                // check response content type
                if(response.headers().has(_XPLATSTR("Content-Type")))
                {
                    utility::string_t contentType = response.headers()[_XPLATSTR("Content-Type")];
                    if(contentType.find(responseHttpContentType) == std::string::npos)
                    {
                        return pplx::task_from_exception<RequestResponse>(ApiException(500
                                                                        , _XPLATSTR("Error calling {{classname}}.{{operationId}}: unexpected response type: ") + contentType
                                                                        , response.headers()
                                                                        , std::make_shared<std::stringstream>(response.extract_utf8string(true).get())));
                    }
                }
{{#vendorExtensions.x-codegen-response-ishttpcontent}}
                return response.extract_vector();
            }, token).then([](std::vector<unsigned char> response)
            {
                pQosTracker;

                HttpContent result;
                std::shared_ptr<std::stringstream> stream = std::make_shared<std::stringstream>(std::string(response.begin(), response.end()));
                result.setData(stream);
                return result;
{{/vendorExtensions.x-codegen-response-ishttpcontent}}
{{^vendorExtensions.x-codegen-response-ishttpcontent}}
                const auto& headers = response.headers();
                const auto it = headers.find(_XPLATSTR("x-request-id"));
                auto requestId = it != headers.end() ? utility::conversions::to_utf8string(it->second) : std::string();

{{^returnType}}
                return pplx::task_from_result<HttpResponse>(requestId.c_str());
{{/returnType}}
{{#returnType}}
                return response.extract_string().then([ responseHttpContentType, requestId ](utility::string_t response)
                {
{{#returnContainer}}
                    {{{returnType}}} result;
{{/returnContainer}}
{{^returnContainer}}
                    {{{returnType}}} result({{{defaultResponse}}});
{{/returnContainer}}

                    if(responseHttpContentType == _XPLATSTR("application/json"))
                    {
                        web::json::value json = web::json::value::parse(response);

{{#isListContainer}}
                        for( auto& item : json.as_array() )
                        {
{{#vendorExtensions.x-codegen-response.items.isPrimitiveType}}
                            result.push_back(ModelBase::{{vendorExtensions.x-codegen-response.items.datatype}}FromJson(item));
{{/vendorExtensions.x-codegen-response.items.isPrimitiveType}}
{{^vendorExtensions.x-codegen-response.items.isPrimitiveType}}
{{#vendorExtensions.x-codegen-response.items.isString}}
                            result.push_back(ModelBase::stringFromJson(item));
{{/vendorExtensions.x-codegen-response.items.isString}}
{{^vendorExtensions.x-codegen-response.items.isString}}
                            {{{vendorExtensions.x-codegen-response.items.datatype}}} itemObj({{{vendorExtensions.x-codegen-response.items.defaultValue}}});
                            itemObj->fromJson(item);
                            result.push_back(itemObj);
{{/vendorExtensions.x-codegen-response.items.isString}}
{{/vendorExtensions.x-codegen-response.items.isPrimitiveType}}
                        }
{{/isListContainer}}
{{^isListContainer}}
{{#isMapContainer}}
                        for( auto& item : json.as_object() )
                        {
{{#vendorExtensions.x-codegen-response.items.isPrimitiveType}}
                            result[item.first] = ModelBase::{{vendorExtensions.x-codegen-response.items.datatype}}FromJson(item.second);
{{/vendorExtensions.x-codegen-response.items.isPrimitiveType}}
{{^vendorExtensions.x-codegen-response.items.isPrimitiveType}}
{{#vendorExtensions.x-codegen-response.items.isString}}
                            result[item.first] = ModelBase::stringFromJson(item.second);
{{/vendorExtensions.x-codegen-response.items.isString}}
{{^vendorExtensions.x-codegen-response.items.isString}}
                            {{{vendorExtensions.x-codegen-response.items.datatype}}} itemObj({{{vendorExtensions.x-codegen-response.items.defaultValue}}});
                            itemObj->fromJson(item);
                            result[item.first] = itemObj;
{{/vendorExtensions.x-codegen-response.items.isString}}
{{/vendorExtensions.x-codegen-response.items.isPrimitiveType}}
                        }
{{/isMapContainer}}
{{^isMapContainer}}
{{#vendorExtensions.x-codegen-response.isPrimitiveType}}
                        result = ModelBase::{{vendorExtensions.x-codegen-response.items.datatype}}FromJson(json);
{{/vendorExtensions.x-codegen-response.isPrimitiveType}}
{{^vendorExtensions.x-codegen-response.isPrimitiveType}}
{{#vendorExtensions.x-codegen-response.isString}}
                        result = ModelBase::stringFromJson(json);
{{/vendorExtensions.x-codegen-response.isString}}
{{^vendorExtensions.x-codegen-response.isString}}
{{#vendorExtensions.x-codegen-response-isPlainObject}}
                        result->setBody(response);
{{/vendorExtensions.x-codegen-response-isPlainObject}}
{{^vendorExtensions.x-codegen-response-isPlainObject}}
                        result->fromJson(json);
{{/vendorExtensions.x-codegen-response-isPlainObject}}
{{/vendorExtensions.x-codegen-response.isString}}
{{/vendorExtensions.x-codegen-response.isPrimitiveType}}
{{/isMapContainer}}
{{/isListContainer}}
                    }
{{#vendorExtensions.x-codegen-response.isString}}
                    else if(responseHttpContentType == _XPLATSTR("text/plain"))
                    {
                        result = response;
                    }
{{/vendorExtensions.x-codegen-response.isString}}

// else if(responseHttpContentType == _XPLATSTR("multipart/form-data"))
// {
// TODO multipart response parsing
// }

                    else
                    {
                        throw ApiException(500, _XPLATSTR("Error calling {{classname}}.{{operationId}}: unsupported response type"));
                    }

                    return HttpResponseT<{{{returnType}}}>(requestId.c_str(), result);
                });
{{/returnType}}
{{/vendorExtensions.x-codegen-response-ishttpcontent}}
            }, token);
        };

        retryInfo.operationId = _XPLATSTR("{{classname}}.{{operationId}}");

        auto resultTask = retryInfo.requestRetryTimeoutSec == RetryInfo::NoRetry
                            ? taskGenerator()
                            : Helpers::Retry<RequestResponse>(std::move(taskGenerator), std::move(retryInfo));

        return RequestTask<RequestResponse>(reqInfo, resultTask);

    }
    catch(const ApiException& ex)
    {
        return RequestTask<RequestResponse>(reqInfo, pplx::task_from_exception<RequestResponse>(ex));
    }
    catch(const std::exception& ex)
    {
        return RequestTask<RequestResponse>(reqInfo, pplx::task_from_exception<RequestResponse>(ex));
    }
}

HttpRequestInfo {{classname}}::{{operationId}}RequestInfo({{#pathParams}}{{{dataType}}} {{paramName}}{{^required}}{{/required}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}) const
{
    utility::string_t httpMethod = _XPLATSTR("{{httpMethod}}");
    utility::string_t path = _XPLATSTR("{{path}}");
    {{#pathParams}}boost::replace_all(path, _XPLATSTR("{") _XPLATSTR("{{baseName}}") _XPLATSTR("}"), ApiClient::parameterToString({{{paramName}}}));
    {{/pathParams}}

    return HttpRequestInfo(httpMethod, path);
}

void {{classname}}::{{operationId}}QosLimit(int limit)
{
    SetQosLimit("{{operationId}}", limit);
}
{{/operation}}
{{#apiNamespaceDeclarations}}
}
{{/apiNamespaceDeclarations}}
{{/operations}}
